---
phase: 01-backend-api
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/src/services/gemini.ts
  - backend/src/routes/explain.ts
  - backend/src/routes/chat.ts
  - backend/src/index.ts
  - backend/src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "POST /explain returns plain-language explanation for a question"
    - "POST /chat returns contextual response with conversation history"
    - "Gemini API generates responses at 6th grade reading level"
    - "Error responses return appropriate HTTP status codes"
  artifacts:
    - path: "backend/src/services/gemini.ts"
      provides: "Gemini SDK integration with prompt templates"
      exports: ["explainQuestion", "chatAboutQuestion"]
    - path: "backend/src/routes/explain.ts"
      provides: "POST /explain endpoint"
      exports: ["explainRouter"]
    - path: "backend/src/routes/chat.ts"
      provides: "POST /chat endpoint"
      exports: ["chatRouter"]
    - path: "backend/src/types/index.ts"
      provides: "TypeScript interfaces for API requests/responses"
      exports: ["ExplainRequest", "ExplainResponse", "ChatRequest", "ChatResponse"]
  key_links:
    - from: "backend/src/routes/explain.ts"
      to: "backend/src/services/gemini.ts"
      via: "import and function call"
      pattern: "import.*explainQuestion"
    - from: "backend/src/routes/chat.ts"
      to: "backend/src/services/gemini.ts"
      via: "import and function call"
      pattern: "import.*chatAboutQuestion"
    - from: "backend/src/index.ts"
      to: "backend/src/routes/explain.ts"
      via: "app.use('/explain')"
      pattern: "app\\.use.*explainRouter"
---

<objective>
Integrate Gemini AI and create /explain and /chat endpoints

Purpose: Enable the API to generate plain-language explanations for form questions using Gemini
Output: Working /explain and /chat endpoints that return AI-generated responses
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-backend-api/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types and Gemini service</name>
  <files>
    backend/src/types/index.ts
    backend/src/services/gemini.ts
  </files>
  <action>
Create TypeScript interfaces and the Gemini service with prompt templates.

1. Create backend/src/types/index.ts:

```typescript
export interface ExplainRequest {
  questionId: string;
  originalText: string;
  fieldType: string;
  required: boolean;
  context?: string;
  commonConfusions?: string;
  userContext?: string;
}

export interface ExplainResponse {
  explanation: string;
  questionId: string;
}

export interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

export interface ChatRequest {
  questionId: string;
  originalText: string;
  fieldType: string;
  context?: string;
  conversationHistory: ChatMessage[];
  userMessage: string;
  currentAnswers?: Record<string, string>;
}

export interface ChatResponse {
  message: string;
  suggestedAnswer?: string;
  confidence?: 'low' | 'medium' | 'high';
}

export interface QuestionData {
  id: string;
  originalText: string;
  fieldType: string;
  required: boolean;
  context?: string;
  commonConfusions?: string;
}
```

2. Create backend/src/services/gemini.ts:

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';
import { ExplainRequest, ChatRequest, ChatMessage } from '../types';

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');

const EXPLAIN_SYSTEM_PROMPT = `You are a helpful assistant that explains Ontario government form questions in simple, clear language.

Your job is to:
1. Explain what the question is really asking in plain English (6th grade reading level)
2. Give concrete examples relevant to Ontario residents
3. Clarify any confusing terms
4. Help them figure out what to enter

RULES:
- Use short sentences (under 15 words when possible)
- Avoid jargon and legal terms
- Give specific examples, not abstract explanations
- If unsure about Ontario Works rules, say "I'm not certain about this specific rule"
- Be warm and encouraging`;

const CHAT_SYSTEM_PROMPT = `You are helping someone fill out an Ontario Works (social assistance) application.

YOUR ROLE:
1. Answer follow-up questions about this specific field
2. Help them figure out what applies to their situation
3. When confident, suggest what to enter: "Based on what you told me, you should enter: [ANSWER]"
4. If unsure, ask ONE clarifying question

RULES:
- Keep responses SHORT (2-3 sentences max)
- You're not a lawyer - don't guarantee outcomes
- If unsure about Ontario Works rules, say so
- Be warm and encouraging`;

export async function explainQuestion(request: ExplainRequest): Promise<string> {
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  const prompt = `${EXPLAIN_SYSTEM_PROMPT}

QUESTION CONTEXT:
Original question: "${request.originalText}"
Field type: ${request.fieldType}
Required: ${request.required}

${request.context ? `Background information:\n${request.context}` : ''}

${request.commonConfusions ? `Common confusions:\n${request.commonConfusions}` : ''}

${request.userContext ? `User's situation:\n${request.userContext}` : ''}

Please explain this question in simple terms:`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

export async function chatAboutQuestion(request: ChatRequest): Promise<{
  message: string;
  suggestedAnswer?: string;
  confidence?: 'low' | 'medium' | 'high';
}> {
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

  // Build conversation history string
  const historyText = request.conversationHistory
    .map((msg: ChatMessage) => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
    .join('\n');

  const currentAnswersText = request.currentAnswers
    ? Object.entries(request.currentAnswers)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n')
    : 'None provided';

  const prompt = `${CHAT_SYSTEM_PROMPT}

CURRENT QUESTION:
"${request.originalText}"
Field type: ${request.fieldType}

${request.context ? `CONTEXT:\n${request.context}` : ''}

USER'S OTHER ANSWERS:
${currentAnswersText}

CONVERSATION SO FAR:
${historyText}

User: ${request.userMessage}

Respond helpfully. If you can suggest an answer, format it as:
SUGGESTED_ANSWER: [your suggestion]
CONFIDENCE: [low/medium/high]

Otherwise just respond conversationally.`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  const text = response.text();

  // Parse response for suggested answer
  const suggestedMatch = text.match(/SUGGESTED_ANSWER:\s*(.+?)(?:\n|$)/i);
  const confidenceMatch = text.match(/CONFIDENCE:\s*(low|medium|high)/i);

  // Clean the message by removing the metadata lines
  let cleanMessage = text
    .replace(/SUGGESTED_ANSWER:\s*.+?(?:\n|$)/gi, '')
    .replace(/CONFIDENCE:\s*(low|medium|high)/gi, '')
    .trim();

  return {
    message: cleanMessage,
    suggestedAnswer: suggestedMatch ? suggestedMatch[1].trim() : undefined,
    confidence: confidenceMatch
      ? (confidenceMatch[1].toLowerCase() as 'low' | 'medium' | 'high')
      : undefined,
  };
}
```
  </action>
  <verify>
cd backend && npx tsc --noEmit
  </verify>
  <done>
TypeScript compiles without errors, types are defined, Gemini service exports explainQuestion and chatAboutQuestion functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /explain and /chat route handlers</name>
  <files>
    backend/src/routes/explain.ts
    backend/src/routes/chat.ts
  </files>
  <action>
Create the route handlers for the /explain and /chat endpoints.

1. Create backend/src/routes/explain.ts:

```typescript
import { Router, Request, Response } from 'express';
import { explainQuestion } from '../services/gemini';
import { ExplainRequest, ExplainResponse } from '../types';

const router = Router();

router.post('/', async (req: Request, res: Response) => {
  try {
    const {
      questionId,
      originalText,
      fieldType,
      required,
      context,
      commonConfusions,
      userContext,
    } = req.body as ExplainRequest;

    // Validate required fields
    if (!questionId || !originalText || !fieldType) {
      res.status(400).json({
        error: 'Missing required fields',
        required: ['questionId', 'originalText', 'fieldType'],
      });
      return;
    }

    const explanation = await explainQuestion({
      questionId,
      originalText,
      fieldType,
      required: required ?? false,
      context,
      commonConfusions,
      userContext,
    });

    const response: ExplainResponse = {
      explanation,
      questionId,
    };

    res.json(response);
  } catch (error) {
    console.error('Error in /explain:', error);
    res.status(500).json({
      error: 'Failed to generate explanation',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export { router as explainRouter };
```

2. Create backend/src/routes/chat.ts:

```typescript
import { Router, Request, Response } from 'express';
import { chatAboutQuestion } from '../services/gemini';
import { ChatRequest, ChatResponse } from '../types';

const router = Router();

router.post('/', async (req: Request, res: Response) => {
  try {
    const {
      questionId,
      originalText,
      fieldType,
      context,
      conversationHistory,
      userMessage,
      currentAnswers,
    } = req.body as ChatRequest;

    // Validate required fields
    if (!questionId || !originalText || !fieldType || !userMessage) {
      res.status(400).json({
        error: 'Missing required fields',
        required: ['questionId', 'originalText', 'fieldType', 'userMessage'],
      });
      return;
    }

    const result = await chatAboutQuestion({
      questionId,
      originalText,
      fieldType,
      context,
      conversationHistory: conversationHistory || [],
      userMessage,
      currentAnswers,
    });

    const response: ChatResponse = {
      message: result.message,
      suggestedAnswer: result.suggestedAnswer,
      confidence: result.confidence,
    };

    res.json(response);
  } catch (error) {
    console.error('Error in /chat:', error);
    res.status(500).json({
      error: 'Failed to generate response',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

export { router as chatRouter };
```
  </action>
  <verify>
cd backend && npx tsc --noEmit
  </verify>
  <done>
Route handlers created with proper validation, error handling, and TypeScript types
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up routes to Express app</name>
  <files>
    backend/src/index.ts
  </files>
  <action>
Update the main Express app to use the new routes.

Update backend/src/index.ts to include the new routes:

```typescript
import express, { Request, Response, NextFunction } from 'express';
import dotenv from 'dotenv';
import { corsMiddleware } from './middleware/cors';
import { explainRouter } from './routes/explain';
import { chatRouter } from './routes/chat';

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(corsMiddleware);
app.use(express.json());

// Health check endpoint
app.get('/', (req: Request, res: Response) => {
  res.json({
    status: 'ok',
    message: 'FormBridge API is running',
    timestamp: new Date().toISOString(),
  });
});

// API routes
app.use('/explain', explainRouter);
app.use('/chat', chatRouter);

// 404 handler
app.use((req: Request, res: Response) => {
  res.status(404).json({
    error: 'Not found',
    path: req.path,
  });
});

// Error handling middleware
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('Error:', err.message);
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  console.log('Available endpoints:');
  console.log('  GET  /         - Health check');
  console.log('  POST /explain  - Get explanation for a form question');
  console.log('  POST /chat     - Chat about a form question');
});

export { app };
```
  </action>
  <verify>
cd backend && npm run build && ls dist/index.js dist/routes/explain.js dist/routes/chat.js dist/services/gemini.js
  </verify>
  <done>
TypeScript builds successfully, all routes wired up, server logs available endpoints on startup
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npm run build` completes without errors
2. `npm run dev` starts server and logs all available endpoints
3. Test /explain endpoint (requires valid GEMINI_API_KEY in .env):
```bash
curl -X POST http://localhost:5000/explain \
  -H "Content-Type: application/json" \
  -d '{"questionId": "q1", "originalText": "Number of people in your household", "fieldType": "number", "required": true}'
```
4. Test /chat endpoint:
```bash
curl -X POST http://localhost:5000/chat \
  -H "Content-Type: application/json" \
  -d '{"questionId": "q1", "originalText": "Number of people in your household", "fieldType": "number", "userMessage": "Does my girlfriend count if she stays over sometimes?", "conversationHistory": []}'
```
5. Test validation (should return 400):
```bash
curl -X POST http://localhost:5000/explain \
  -H "Content-Type: application/json" \
  -d '{}'
```
</verification>

<success_criteria>
- POST /explain returns plain-language explanation with questionId
- POST /chat returns contextual response with optional suggestedAnswer
- Missing required fields return 400 with helpful error message
- Gemini API errors are caught and return 500
- TypeScript compiles without errors
- All routes properly connected to Express app
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-api/01-02-SUMMARY.md`
</output>
