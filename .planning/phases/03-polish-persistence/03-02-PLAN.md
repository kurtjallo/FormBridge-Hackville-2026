---
phase: 03-polish-persistence
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/src/lib/validation.ts
  - frontend/src/lib/api.ts
  - frontend/src/components/FormQuestion.tsx
  - frontend/src/components/ProgressBar.tsx
  - frontend/src/components/ChatPanel.tsx
  - frontend/src/store/formStore.ts
  - frontend/src/app/page.tsx
  - frontend/src/app/globals.css
autonomous: true

must_haves:
  truths:
    - "Progress bar updates as sections are completed"
    - "Canadian postal codes are validated (Ontario prefixes K, L, M, N, P)"
    - "SINs are validated with Luhn algorithm"
    - "Session persists across browser refresh"
    - "Layout works on mobile devices"
  artifacts:
    - path: "frontend/src/lib/validation.ts"
      provides: "Canadian validation utilities"
      exports: ["isValidCanadianPostalCode", "isOntarioPostalCode", "isValidSIN"]
    - path: "frontend/src/lib/api.ts"
      provides: "Session API functions"
      exports: ["saveSession", "loadSession"]
  key_links:
    - from: "frontend/src/store/formStore.ts"
      to: "frontend/src/lib/api.ts"
      via: "session persistence calls"
      pattern: "(saveSession|loadSession)"
    - from: "frontend/src/components/ProgressBar.tsx"
      to: "frontend/src/store/formStore.ts"
      via: "completion calculation"
      pattern: "completedSections|answers"
    - from: "frontend/src/components/FormQuestion.tsx"
      to: "frontend/src/lib/validation.ts"
      via: "validation on blur"
      pattern: "(isValidSIN|isValidCanadianPostalCode)"
---

<objective>
Add progress tracking, Canadian validation, session persistence, and mobile responsive design to the frontend.

Purpose: Complete the user experience with visual progress feedback, data validation, persistence across sessions, and mobile support.

Output: Polished frontend with working progress bar, validation feedback, session save/load, and responsive layout.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-polish-persistence/03-01-SUMMARY.md

Frontend structure:
- Next.js 14 with App Router
- Zustand store in frontend/src/store/formStore.ts
- Form data in frontend/src/data/ontarioWorksForm.ts (5 sections)
- Components: ProgressBar, FormSection, FormQuestion, ChatPanel
- API client in frontend/src/lib/api.ts

Current ProgressBar uses completedSections from store but sections are not auto-marked complete.
Need to calculate completion based on answers.

Session endpoints from 03-01:
- GET /session/:id - Load session
- POST /session - Save session

Requirements:
- FORM-04: Progress bar shows section completion status
- FORM-05: Mobile responsive layout
- DATA-03: Canadian postal code validation (Ontario prefixes K, L, M, N, P)
- DATA-04: SIN validation with Luhn algorithm
- STATE-04: Session ID tracking for persistence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Canadian validation utilities and update progress calculation</name>
  <files>
    frontend/src/lib/validation.ts
    frontend/src/store/formStore.ts
    frontend/src/components/ProgressBar.tsx
  </files>
  <action>
1. Create frontend/src/lib/validation.ts with Canadian validation utilities:
   ```typescript
   // Postal code validation
   export function isValidCanadianPostalCode(code: string): boolean {
     return /^[A-Za-z]\d[A-Za-z][ -]?\d[A-Za-z]\d$/.test(code);
   }

   export function isOntarioPostalCode(code: string): boolean {
     const firstChar = code.charAt(0).toUpperCase();
     return ['K', 'L', 'M', 'N', 'P'].includes(firstChar);
   }

   // SIN validation with Luhn algorithm
   export function isValidSIN(sin: string): boolean {
     const digits = sin.replace(/\D/g, '');
     if (digits.length !== 9) return false;

     let sum = 0;
     for (let i = 0; i < 9; i++) {
       let digit = parseInt(digits[i]);
       if (i % 2 === 1) {
         digit *= 2;
         if (digit > 9) digit -= 9;
       }
       sum += digit;
     }
     return sum % 10 === 0;
   }

   // Check if SIN indicates temporary resident
   export function isTemporaryResidentSIN(sin: string): boolean {
     return sin.replace(/\D/g, '').startsWith('9');
   }

   // Format SIN for display (XXX-XXX-XXX)
   export function formatSIN(sin: string): string {
     const digits = sin.replace(/\D/g, '');
     if (digits.length !== 9) return sin;
     return `${digits.slice(0, 3)}-${digits.slice(3, 6)}-${digits.slice(6, 9)}`;
   }

   // Format postal code for display (A1A 1A1)
   export function formatPostalCode(code: string): string {
     const cleaned = code.replace(/\s|-/g, '').toUpperCase();
     if (cleaned.length !== 6) return code;
     return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)}`;
   }

   export interface ValidationResult {
     valid: boolean;
     message?: string;
   }

   export function validateField(fieldId: string, value: string): ValidationResult {
     // SIN validation
     if (fieldId.toLowerCase().includes('sin')) {
       if (!value) return { valid: true };
       if (!isValidSIN(value)) {
         return { valid: false, message: 'Please enter a valid 9-digit SIN' };
       }
       if (isTemporaryResidentSIN(value)) {
         return { valid: true, message: 'Note: This SIN indicates temporary resident status' };
       }
       return { valid: true };
     }

     // Postal code validation
     if (fieldId.toLowerCase().includes('postal')) {
       if (!value) return { valid: true };
       if (!isValidCanadianPostalCode(value)) {
         return { valid: false, message: 'Please enter a valid Canadian postal code (e.g., M5V 1A1)' };
       }
       if (!isOntarioPostalCode(value)) {
         return { valid: true, message: 'Note: This postal code is outside Ontario' };
       }
       return { valid: true };
     }

     return { valid: true };
   }
   ```

2. Update frontend/src/store/formStore.ts to add validation state and computed section completion:
   Add to FormState interface in frontend/src/types/index.ts:
   ```typescript
   // Add to FormState interface
   validationErrors: Record<string, string>;
   setValidationError: (fieldId: string, error: string | null) => void;
   clearValidationErrors: () => void;
   ```

   Update formStore.ts:
   ```typescript
   import { create } from 'zustand';
   import { persist } from 'zustand/middleware';
   import { FormState, ChatMessage } from '@/types';

   const initialState = {
     answers: {},
     activeQuestionId: null,
     conversations: {},
     sessionId: null,
     completedSections: [],
     validationErrors: {},
   };

   export const useFormStore = create<FormState>()(
     persist(
       (set) => ({
         ...initialState,

         setAnswer: (fieldId: string, value: string | number | boolean) =>
           set((state) => ({
             answers: { ...state.answers, [fieldId]: value },
           })),

         setActiveQuestion: (id: string | null) =>
           set({ activeQuestionId: id }),

         addMessage: (questionId: string, message: ChatMessage) =>
           set((state) => ({
             conversations: {
               ...state.conversations,
               [questionId]: [...(state.conversations[questionId] || []), message],
             },
           })),

         setSessionId: (id: string) =>
           set({ sessionId: id }),

         markSectionComplete: (sectionId: string) =>
           set((state) => ({
             completedSections: state.completedSections.includes(sectionId)
               ? state.completedSections
               : [...state.completedSections, sectionId],
           })),

         setValidationError: (fieldId: string, error: string | null) =>
           set((state) => {
             if (error === null) {
               const { [fieldId]: _, ...rest } = state.validationErrors;
               return { validationErrors: rest };
             }
             return { validationErrors: { ...state.validationErrors, [fieldId]: error } };
           }),

         clearValidationErrors: () =>
           set({ validationErrors: {} }),

         reset: () => set(initialState),
       }),
       {
         name: 'formbridge-storage',
         partialize: (state) => ({
           answers: state.answers,
           sessionId: state.sessionId,
           completedSections: state.completedSections,
           conversations: state.conversations,
         }),
       }
     )
   );
   ```

3. Update frontend/src/components/ProgressBar.tsx to calculate completion from answers:
   ```typescript
   'use client';

   import { useFormStore } from '@/store/formStore';
   import { FormSection } from '@/types';
   import { CheckCircle, Circle, AlertCircle } from 'lucide-react';
   import { useMemo } from 'react';

   interface ProgressBarProps {
     sections: FormSection[];
   }

   export function ProgressBar({ sections }: ProgressBarProps) {
     const answers = useFormStore((state) => state.answers);

     // Calculate section completion based on answered required questions
     const sectionStatus = useMemo(() => {
       return sections.map((section) => {
         const requiredQuestions = section.questions.filter((q) => q.required);
         const answeredRequired = requiredQuestions.filter((q) => {
           const answer = answers[q.fieldId];
           if (answer === undefined || answer === null || answer === '') return false;
           if (typeof answer === 'boolean') return answer === true;
           return true;
         });

         const totalQuestions = section.questions.length;
         const answeredTotal = section.questions.filter((q) => {
           const answer = answers[q.fieldId];
           return answer !== undefined && answer !== null && answer !== '';
         }).length;

         return {
           id: section.id,
           complete: requiredQuestions.length > 0 && answeredRequired.length === requiredQuestions.length,
           progress: totalQuestions > 0 ? answeredTotal / totalQuestions : 0,
           answeredRequired: answeredRequired.length,
           totalRequired: requiredQuestions.length,
         };
       });
     }, [answers, sections]);

     const completedCount = sectionStatus.filter((s) => s.complete).length;
     const totalCount = sections.length;
     const progressPercent = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

     return (
       <div className="bg-white border-b border-gray-200 px-4 sm:px-6 py-4">
         <div className="max-w-4xl mx-auto">
           <div className="flex items-center justify-between mb-2">
             <span className="text-sm font-medium text-gray-700">
               Progress: {completedCount} of {totalCount} sections complete
             </span>
             <span className="text-sm text-gray-500">{Math.round(progressPercent)}%</span>
           </div>

           <div className="w-full bg-gray-200 rounded-full h-2 mb-4">
             <div
               className="bg-blue-600 h-2 rounded-full transition-all duration-300"
               style={{ width: `${progressPercent}%` }}
             />
           </div>

           <div className="flex justify-between">
             {sections.map((section, index) => {
               const status = sectionStatus[index];
               return (
                 <div key={section.id} className="flex flex-col items-center">
                   {status.complete ? (
                     <CheckCircle className="w-5 h-5 text-green-600" />
                   ) : status.progress > 0 ? (
                     <AlertCircle className="w-5 h-5 text-yellow-500" />
                   ) : (
                     <Circle className="w-5 h-5 text-gray-300" />
                   )}
                   <span
                     className={`text-xs mt-1 hidden sm:block ${
                       status.complete
                         ? 'text-green-600'
                         : status.progress > 0
                         ? 'text-yellow-600'
                         : 'text-gray-400'
                     }`}
                   >
                     {index + 1}. {section.title.split(' ')[0]}
                   </span>
                   <span
                     className={`text-xs mt-1 sm:hidden ${
                       status.complete
                         ? 'text-green-600'
                         : status.progress > 0
                         ? 'text-yellow-600'
                         : 'text-gray-400'
                     }`}
                   >
                     {index + 1}
                   </span>
                 </div>
               );
             })}
           </div>
         </div>
       </div>
     );
   }
   ```
  </action>
  <verify>
    - `cat frontend/src/lib/validation.ts` shows isValidSIN with Luhn algorithm
    - `cat frontend/src/store/formStore.ts` shows persist middleware and validationErrors
    - `cat frontend/src/components/ProgressBar.tsx` shows sectionStatus calculation from answers
  </verify>
  <done>Validation utilities created, store updated with persistence, ProgressBar calculates completion from answers</done>
</task>

<task type="auto">
  <name>Task 2: Add validation to form inputs and session API functions</name>
  <files>
    frontend/src/components/FormQuestion.tsx
    frontend/src/lib/api.ts
    frontend/src/types/index.ts
  </files>
  <action>
1. Update frontend/src/types/index.ts to add validation types:
   ```typescript
   // Add to existing types

   // Validation state
   validationErrors: Record<string, string>;
   setValidationError: (fieldId: string, error: string | null) => void;
   clearValidationErrors: () => void;
   ```

2. Update frontend/src/components/FormQuestion.tsx to show validation errors:
   ```typescript
   'use client';

   import { useFormStore } from '@/store/formStore';
   import { FormQuestion as FormQuestionType } from '@/types';
   import { HelpCircle, AlertCircle } from 'lucide-react';
   import { validateField } from '@/lib/validation';

   interface FormQuestionProps {
     question: FormQuestionType;
     onHelpClick: () => void;
   }

   export function FormQuestion({ question, onHelpClick }: FormQuestionProps) {
     const answers = useFormStore((state) => state.answers);
     const setAnswer = useFormStore((state) => state.setAnswer);
     const validationErrors = useFormStore((state) => state.validationErrors);
     const setValidationError = useFormStore((state) => state.setValidationError);

     const value = answers[question.fieldId] ?? '';
     const error = validationErrors[question.fieldId];

     const handleChange = (newValue: string | number | boolean) => {
       setAnswer(question.fieldId, newValue);
       // Clear error on change
       if (error) {
         setValidationError(question.fieldId, null);
       }
     };

     const handleBlur = () => {
       if (typeof value === 'string') {
         const result = validateField(question.fieldId, value);
         if (!result.valid && result.message) {
           setValidationError(question.fieldId, result.message);
         }
       }
     };

     const inputClasses = `w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 ${
       error ? 'border-red-500 bg-red-50' : 'border-gray-300'
     }`;

     const renderInput = () => {
       switch (question.fieldType) {
         case 'select':
           return (
             <select
               value={value as string}
               onChange={(e) => handleChange(e.target.value)}
               onBlur={handleBlur}
               className={`${inputClasses} bg-white`}
             >
               <option value="">Select an option...</option>
               {question.options?.map((option) => (
                 <option key={option} value={option}>
                   {option}
                 </option>
               ))}
             </select>
           );

         case 'textarea':
           return (
             <textarea
               value={value as string}
               onChange={(e) => handleChange(e.target.value)}
               onBlur={handleBlur}
               rows={3}
               className={`${inputClasses} resize-none`}
               placeholder="Enter your response..."
             />
           );

         case 'number':
           return (
             <input
               type="number"
               value={value as string}
               onChange={(e) => handleChange(e.target.value ? Number(e.target.value) : '')}
               onBlur={handleBlur}
               className={inputClasses}
               placeholder="Enter a number..."
               min={0}
             />
           );

         case 'checkbox':
           return (
             <label className="flex items-start gap-3 cursor-pointer">
               <input
                 type="checkbox"
                 checked={Boolean(value)}
                 onChange={(e) => handleChange(e.target.checked)}
                 className="mt-1 w-5 h-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
               />
               <span className="text-gray-700">{question.originalText}</span>
             </label>
           );

         case 'text':
         default:
           return (
             <input
               type="text"
               value={value as string}
               onChange={(e) => handleChange(e.target.value)}
               onBlur={handleBlur}
               className={inputClasses}
               placeholder="Enter your response..."
             />
           );
       }
     };

     return (
       <div className="space-y-2">
         <div className="flex items-start justify-between gap-2 sm:gap-4">
           {question.fieldType !== 'checkbox' && (
             <label className="block text-gray-800 font-medium text-sm sm:text-base">
               {question.originalText}
               {question.required && <span className="text-red-500 ml-1">*</span>}
             </label>
           )}
           <button
             onClick={onHelpClick}
             className="flex-shrink-0 p-1 text-blue-600 hover:text-blue-800 hover:bg-blue-50 rounded-full transition-colors"
             title="Get help with this question"
             aria-label="Get help with this question"
           >
             <HelpCircle className="w-5 h-5" />
           </button>
         </div>

         {renderInput()}

         {error && (
           <div className="flex items-center gap-2 text-red-600 text-sm">
             <AlertCircle className="w-4 h-4 flex-shrink-0" />
             <span>{error}</span>
           </div>
         )}
       </div>
     );
   }
   ```

3. Add session API functions to frontend/src/lib/api.ts:
   ```typescript
   import { ChatMessage } from '@/types';

   const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5001';

   export interface ChatRequest {
     questionId: string;
     originalText: string;
     fieldType: string;
     context?: string;
     conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }>;
     userMessage: string;
     currentAnswers?: Record<string, string | number | boolean>;
   }

   export interface ChatResponse {
     message: string;
     suggestedAnswer?: string;
     confidence?: 'low' | 'medium' | 'high';
   }

   export async function chatWithAI(request: ChatRequest): Promise<ChatResponse> {
     const response = await fetch(`${API_URL}/chat`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify(request),
     });

     if (!response.ok) {
       const error = await response.json().catch(() => ({ error: 'Unknown error' }));
       throw new Error(error.error || `API error: ${response.status}`);
     }

     return response.json();
   }

   // Session API

   export interface SessionData {
     sessionId: string;
     answers: Record<string, string | number | boolean>;
     conversations: Record<string, ChatMessage[]>;
     completedSections: string[];
     createdAt?: string;
     updatedAt?: string;
   }

   export interface SaveSessionRequest {
     sessionId?: string;
     answers: Record<string, string | number | boolean>;
     conversations?: Record<string, ChatMessage[]>;
     completedSections?: string[];
   }

   export async function saveSession(data: SaveSessionRequest): Promise<{ sessionId: string }> {
     const response = await fetch(`${API_URL}/session`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify(data),
     });

     if (!response.ok) {
       const error = await response.json().catch(() => ({ error: 'Unknown error' }));
       throw new Error(error.error || `API error: ${response.status}`);
     }

     return response.json();
   }

   export async function loadSession(sessionId: string): Promise<SessionData> {
     const response = await fetch(`${API_URL}/session/${sessionId}`);

     if (!response.ok) {
       if (response.status === 404) {
         throw new Error('Session not found');
       }
       const error = await response.json().catch(() => ({ error: 'Unknown error' }));
       throw new Error(error.error || `API error: ${response.status}`);
     }

     return response.json();
   }

   // Validation API

   export interface ValidationIssue {
     fieldId: string;
     message: string;
     severity: 'warning' | 'error';
   }

   export interface ValidateResponse {
     valid: boolean;
     issues: ValidationIssue[];
   }

   export async function validateForm(answers: Record<string, string | number | boolean>): Promise<ValidateResponse> {
     const response = await fetch(`${API_URL}/validate`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       body: JSON.stringify({ answers }),
     });

     if (!response.ok) {
       const error = await response.json().catch(() => ({ error: 'Unknown error' }));
       throw new Error(error.error || `API error: ${response.status}`);
     }

     return response.json();
   }
   ```
  </action>
  <verify>
    - `cat frontend/src/components/FormQuestion.tsx` shows onBlur validation and error display
    - `cat frontend/src/lib/api.ts` shows saveSession, loadSession, validateForm functions
    - `grep -n "validateField" frontend/src/components/FormQuestion.tsx` shows validation import
  </verify>
  <done>FormQuestion shows validation errors, API client has session and validation functions</done>
</task>

<task type="auto">
  <name>Task 3: Add mobile responsive styles and session auto-save</name>
  <files>
    frontend/src/components/ChatPanel.tsx
    frontend/src/app/page.tsx
    frontend/src/app/globals.css
  </files>
  <action>
1. Update frontend/src/components/ChatPanel.tsx for mobile:
   Change the container div classes from:
   ```typescript
   <div className="fixed bottom-0 right-0 w-full md:w-[420px] h-[600px] ...">
   ```
   To:
   ```typescript
   <div className="fixed inset-0 md:inset-auto md:bottom-0 md:right-0 w-full md:w-[420px] h-full md:h-[600px] bg-white border-l border-t border-gray-200 shadow-xl flex flex-col z-50">
   ```

   This makes the chat panel full-screen on mobile.

   Also update the input area for better mobile spacing:
   ```typescript
   <form onSubmit={handleSubmit} className="px-4 pb-4 pb-safe">
   ```

2. Update frontend/src/app/page.tsx to add auto-save and mobile layout:
   ```typescript
   'use client';

   import { useEffect, useCallback, useRef } from 'react';
   import { Header } from '@/components/Header';
   import { ProgressBar } from '@/components/ProgressBar';
   import { FormSection } from '@/components/FormSection';
   import { ChatPanel } from '@/components/ChatPanel';
   import { ontarioWorksForm } from '@/data/ontarioWorksForm';
   import { useFormStore } from '@/store/formStore';
   import { saveSession } from '@/lib/api';

   export default function Home() {
     const setActiveQuestion = useFormStore((state) => state.setActiveQuestion);
     const activeQuestionId = useFormStore((state) => state.activeQuestionId);
     const answers = useFormStore((state) => state.answers);
     const conversations = useFormStore((state) => state.conversations);
     const sessionId = useFormStore((state) => state.sessionId);
     const setSessionId = useFormStore((state) => state.setSessionId);
     const completedSections = useFormStore((state) => state.completedSections);

     const saveTimeoutRef = useRef<NodeJS.Timeout>();

     // Auto-save session when answers change (debounced)
     const autoSave = useCallback(async () => {
       if (Object.keys(answers).length === 0) return;

       try {
         const result = await saveSession({
           sessionId: sessionId || undefined,
           answers,
           conversations,
           completedSections,
         });

         if (!sessionId && result.sessionId) {
           setSessionId(result.sessionId);
         }
       } catch (error) {
         console.error('Auto-save failed:', error);
       }
     }, [answers, conversations, completedSections, sessionId, setSessionId]);

     useEffect(() => {
       // Debounce auto-save by 2 seconds
       if (saveTimeoutRef.current) {
         clearTimeout(saveTimeoutRef.current);
       }
       saveTimeoutRef.current = setTimeout(autoSave, 2000);

       return () => {
         if (saveTimeoutRef.current) {
           clearTimeout(saveTimeoutRef.current);
         }
       };
     }, [answers, autoSave]);

     const handleHelpClick = (questionId: string) => {
       setActiveQuestion(questionId);
     };

     return (
       <div className="min-h-screen bg-gray-50">
         <Header />
         <ProgressBar sections={ontarioWorksForm.sections} />

         <main
           className={`max-w-4xl mx-auto px-4 sm:px-6 py-6 sm:py-8 transition-all duration-300 ${
             activeQuestionId ? 'md:mr-[420px]' : ''
           } ${activeQuestionId ? 'hidden md:block' : ''}`}
         >
           <div className="mb-6">
             <h2 className="text-xl sm:text-2xl font-bold text-gray-900">
               {ontarioWorksForm.name}
             </h2>
             <p className="text-gray-600 mt-1 text-sm sm:text-base">
               {ontarioWorksForm.description}
             </p>
             {sessionId && (
               <p className="text-xs text-gray-400 mt-2">
                 Session: {sessionId.slice(0, 8)}... (auto-saved)
               </p>
             )}
           </div>

           {ontarioWorksForm.sections.map((section, index) => (
             <FormSection
               key={section.id}
               section={section}
               sectionNumber={index + 1}
               onHelpClick={handleHelpClick}
             />
           ))}
         </main>

         <ChatPanel />
       </div>
     );
   }
   ```

3. Update frontend/src/app/globals.css to add mobile-safe area padding:
   Add at the end of the file:
   ```css
   /* Safe area padding for mobile devices with notches */
   .pb-safe {
     padding-bottom: max(1rem, env(safe-area-inset-bottom));
   }

   .pt-safe {
     padding-top: max(0.75rem, env(safe-area-inset-top));
   }

   /* Mobile tap target sizes */
   @media (max-width: 640px) {
     button,
     input[type="checkbox"],
     select {
       min-height: 44px;
     }

     input[type="text"],
     input[type="number"],
     textarea {
       font-size: 16px; /* Prevents iOS zoom on focus */
     }
   }

   /* Hide scrollbar on mobile chat */
   @media (max-width: 768px) {
     .overflow-y-auto {
       -webkit-overflow-scrolling: touch;
     }
   }
   ```

4. Update ChatPanel.tsx fully for mobile responsiveness:
   The full updated ChatPanel.tsx should have:
   - Full screen on mobile (inset-0 on small screens)
   - Safe area padding for notched devices
   - Better touch targets
   - Back button on mobile to return to form

   Add a back button in the header for mobile:
   ```typescript
   <button
     onClick={() => setActiveQuestion(null)}
     className="md:hidden p-1 hover:bg-gray-200 rounded-full transition-colors mr-2"
     aria-label="Back to form"
   >
     <ChevronLeft className="w-5 h-5 text-gray-500" />
   </button>
   ```

   Import ChevronLeft from lucide-react.
  </action>
  <verify>
    - `cat frontend/src/components/ChatPanel.tsx` shows responsive classes (inset-0 md:inset-auto)
    - `cat frontend/src/app/page.tsx` shows auto-save with debounce and mobile classes
    - `cat frontend/src/app/globals.css` shows safe area padding and mobile font-size rules
    - Open app on mobile viewport (Chrome DevTools) - chat panel should be full screen
    - Fill in a form field, wait 2 seconds - should see "Session: xxx (auto-saved)" message
  </verify>
  <done>Mobile responsive layout complete, auto-save implemented with 2-second debounce</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Progress bar updates automatically:
   - Fill in all required fields in a section
   - Progress bar should show that section as complete (green checkmark)
   - Partially filled sections show yellow indicator

2. Canadian validation works:
   - If form had postal code field: Enter invalid postal code, blur -> see error
   - Enter "A1A1A1" -> see "outside Ontario" warning
   - Enter "M5V1A1" -> no error (valid Ontario)
   - If form had SIN field: Enter "123456789" -> likely fails Luhn check
   - Enter valid SIN -> passes

3. Session persistence:
   - Fill in some form answers
   - Wait 2+ seconds (auto-save debounce)
   - Should see "Session: xxx... (auto-saved)" text
   - Refresh page -> answers should persist (localStorage + MongoDB)

4. Mobile responsive:
   - Open Chrome DevTools, toggle device toolbar
   - Select iPhone or mobile viewport
   - Click help button -> chat panel should be full screen
   - Form should have appropriate text sizes and tap targets
   - Chat input should not cause zoom on iOS (16px font-size)

5. Build succeeds:
   ```bash
   cd frontend && npm run build
   ```
   Should complete without errors
</verification>

<success_criteria>
- Progress bar shows section completion based on answered required questions
- Canadian postal codes validated (K, L, M, N, P are Ontario prefixes)
- SINs validated with Luhn algorithm (9 digits, checksum passes)
- Session auto-saves to MongoDB after 2 seconds of inactivity
- Session persists in localStorage for immediate reload
- Chat panel is full-screen on mobile
- Form has appropriate mobile tap targets and font sizes
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish-persistence/03-02-SUMMARY.md`
</output>
