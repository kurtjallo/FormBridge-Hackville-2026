---
phase: 03-polish-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/src/index.ts
  - backend/src/models/Session.ts
  - backend/src/routes/session.ts
  - backend/src/routes/validate.ts
  - backend/src/types/index.ts
autonomous: true
user_setup:
  - service: mongodb
    why: "Session persistence requires MongoDB"
    env_vars:
      - name: MONGODB_URI
        source: "MongoDB Atlas or local MongoDB - connection string like mongodb://localhost:27017/formbridge"

must_haves:
  truths:
    - "POST /session creates or updates session in MongoDB"
    - "GET /session/:id retrieves existing session from MongoDB"
    - "POST /validate checks form answers for consistency"
    - "Session contains answers, conversations, and timestamps"
  artifacts:
    - path: "backend/src/models/Session.ts"
      provides: "Mongoose Session model"
      contains: "mongoose.model"
    - path: "backend/src/routes/session.ts"
      provides: "Session CRUD endpoints"
      exports: ["sessionRouter"]
    - path: "backend/src/routes/validate.ts"
      provides: "Form validation endpoint"
      exports: ["validateRouter"]
  key_links:
    - from: "backend/src/index.ts"
      to: "backend/src/routes/session.ts"
      via: "app.use('/session', sessionRouter)"
      pattern: "app\\.use.*session"
    - from: "backend/src/routes/session.ts"
      to: "backend/src/models/Session.ts"
      via: "mongoose operations"
      pattern: "Session\\.(find|create|update)"
---

<objective>
Add MongoDB session persistence and form validation to the backend API.

Purpose: Enable users to save their form progress and resume later, and validate form answers for consistency before submission.

Output: Working /session and /validate endpoints connected to MongoDB.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

Backend structure:
- Express server on port 5001 with TypeScript
- Existing routes: /explain, /chat
- Types in backend/src/types/index.ts
- Gemini service in backend/src/services/gemini.ts

Frontend store already has sessionId and setSessionId ready:
```typescript
// From frontend/src/store/formStore.ts
sessionId: string | null;
setSessionId: (id: string) => void;
```

Requirements:
- API-04: POST /validate endpoint checks form answers for consistency
- API-05: GET /session/:id loads existing session from MongoDB
- API-06: POST /session saves/creates session in MongoDB
- AI-04: Suggested answers include confidence level (already implemented in gemini.ts)
- STATE-04: Session ID tracking for persistence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Mongoose and create Session model</name>
  <files>
    backend/package.json
    backend/src/models/Session.ts
    backend/src/types/index.ts
  </files>
  <action>
1. Install mongoose dependency:
   ```bash
   cd backend && npm install mongoose && npm install -D @types/mongoose
   ```

2. Create backend/src/models/Session.ts with Mongoose schema:
   ```typescript
   import mongoose, { Document, Schema } from 'mongoose';

   export interface ISession extends Document {
     _id: string;
     answers: Record<string, string | number | boolean>;
     conversations: Record<string, Array<{
       role: 'user' | 'assistant';
       content: string;
       suggestedAnswer?: string;
       confidence?: 'low' | 'medium' | 'high';
       timestamp: number;
     }>>;
     completedSections: string[];
     createdAt: Date;
     updatedAt: Date;
   }

   const SessionSchema = new Schema<ISession>({
     _id: { type: String, required: true },
     answers: { type: Schema.Types.Mixed, default: {} },
     conversations: { type: Schema.Types.Mixed, default: {} },
     completedSections: { type: [String], default: [] },
   }, {
     timestamps: true,
     _id: false,
   });

   export const Session = mongoose.model<ISession>('Session', SessionSchema);
   ```

3. Add session-related types to backend/src/types/index.ts:
   ```typescript
   export interface SessionData {
     sessionId: string;
     answers: Record<string, string | number | boolean>;
     conversations: Record<string, ChatMessage[]>;
     completedSections: string[];
   }

   export interface SaveSessionRequest {
     sessionId?: string;
     answers: Record<string, string | number | boolean>;
     conversations?: Record<string, ChatMessage[]>;
     completedSections?: string[];
   }

   export interface SaveSessionResponse {
     sessionId: string;
     message: string;
   }
   ```
  </action>
  <verify>
    - `ls backend/node_modules/mongoose` confirms mongoose installed
    - `cat backend/src/models/Session.ts` shows Session model with ISession interface
    - `cat backend/src/types/index.ts` shows SessionData and SaveSessionRequest types
  </verify>
  <done>Mongoose installed, Session model created with proper schema, types exported</done>
</task>

<task type="auto">
  <name>Task 2: Create session routes and wire MongoDB connection</name>
  <files>
    backend/src/routes/session.ts
    backend/src/index.ts
  </files>
  <action>
1. Create backend/src/routes/session.ts:
   ```typescript
   import { Router, Request, Response } from 'express';
   import { Session } from '../models/Session';
   import { SaveSessionRequest } from '../types';
   import { v4 as uuidv4 } from 'uuid';

   export const sessionRouter = Router();

   // GET /session/:id - Load existing session
   sessionRouter.get('/:id', async (req: Request, res: Response) => {
     try {
       const session = await Session.findById(req.params.id);

       if (!session) {
         return res.status(404).json({ error: 'Session not found' });
       }

       res.json({
         sessionId: session._id,
         answers: session.answers,
         conversations: session.conversations,
         completedSections: session.completedSections,
         createdAt: session.createdAt,
         updatedAt: session.updatedAt,
       });
     } catch (error) {
       console.error('Error loading session:', error);
       res.status(500).json({ error: 'Failed to load session' });
     }
   });

   // POST /session - Create or update session
   sessionRouter.post('/', async (req: Request<{}, {}, SaveSessionRequest>, res: Response) => {
     try {
       const { sessionId, answers, conversations, completedSections } = req.body;

       const id = sessionId || uuidv4();

       const session = await Session.findByIdAndUpdate(
         id,
         {
           _id: id,
           answers: answers || {},
           conversations: conversations || {},
           completedSections: completedSections || [],
         },
         { upsert: true, new: true, setDefaultsOnInsert: true }
       );

       res.json({
         sessionId: session._id,
         message: sessionId ? 'Session updated' : 'Session created',
       });
     } catch (error) {
       console.error('Error saving session:', error);
       res.status(500).json({ error: 'Failed to save session' });
     }
   });
   ```

2. Install uuid for session ID generation:
   ```bash
   cd backend && npm install uuid && npm install -D @types/uuid
   ```

3. Update backend/src/index.ts to:
   - Import mongoose and connect to MongoDB
   - Add session router

   Add near top after imports:
   ```typescript
   import mongoose from 'mongoose';
   import { sessionRouter } from './routes/session';
   ```

   Add MongoDB connection before app.listen():
   ```typescript
   // Connect to MongoDB
   const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/formbridge';

   mongoose.connect(MONGODB_URI)
     .then(() => console.log('Connected to MongoDB'))
     .catch((err) => console.error('MongoDB connection error:', err));
   ```

   Add route after other API routes:
   ```typescript
   app.use('/session', sessionRouter);
   ```

   Update the console.log endpoints list to include:
   ```typescript
   console.log('  GET  /session/:id - Load session');
   console.log('  POST /session     - Save session');
   ```
  </action>
  <verify>
    - `cat backend/src/routes/session.ts` shows GET /:id and POST / routes
    - `cat backend/src/index.ts` shows mongoose import, connect call, and sessionRouter
    - `grep -n "session" backend/src/index.ts` shows session route registered
  </verify>
  <done>Session routes created, MongoDB connection configured, routes wired to Express app</done>
</task>

<task type="auto">
  <name>Task 3: Create validate endpoint for form consistency checking</name>
  <files>
    backend/src/routes/validate.ts
    backend/src/index.ts
    backend/src/types/index.ts
  </files>
  <action>
1. Add validation types to backend/src/types/index.ts:
   ```typescript
   export interface ValidateRequest {
     answers: Record<string, string | number | boolean>;
   }

   export interface ValidationIssue {
     fieldId: string;
     message: string;
     severity: 'warning' | 'error';
   }

   export interface ValidateResponse {
     valid: boolean;
     issues: ValidationIssue[];
   }
   ```

2. Create backend/src/routes/validate.ts:
   ```typescript
   import { Router, Request, Response } from 'express';
   import { ValidateRequest, ValidateResponse, ValidationIssue } from '../types';

   export const validateRouter = Router();

   // POST /validate - Check form answers for consistency
   validateRouter.post('/', (req: Request<{}, {}, ValidateRequest>, res: Response) => {
     const { answers } = req.body;
     const issues: ValidationIssue[] = [];

     // Check employment income consistency
     if (answers.employmentIncome === 'Yes' && !answers.monthlyEarnings) {
       issues.push({
         fieldId: 'monthlyEarnings',
         message: 'You indicated you have employment income but did not enter monthly earnings',
         severity: 'warning',
       });
     }

     if (answers.employmentIncome === 'No' && answers.monthlyEarnings) {
       issues.push({
         fieldId: 'employmentIncome',
         message: 'You entered monthly earnings but indicated no employment income',
         severity: 'error',
       });
     }

     // Check other income consistency
     if (answers.otherIncome === 'Yes' && !answers.otherIncomeDetails) {
       issues.push({
         fieldId: 'otherIncomeDetails',
         message: 'You indicated other income but did not provide details',
         severity: 'warning',
       });
     }

     // Check housing consistency
     if (answers.housingType === 'Homeless/shelter' && answers.monthlyRent) {
       issues.push({
         fieldId: 'monthlyRent',
         message: 'You indicated homeless/shelter status but entered a rent amount',
         severity: 'warning',
       });
     }

     if (answers.housingType &&
         answers.housingType !== 'Homeless/shelter' &&
         answers.housingType !== 'Living with family/friends (not paying rent)' &&
         !answers.monthlyRent) {
       issues.push({
         fieldId: 'monthlyRent',
         message: 'Please enter your monthly rent or mortgage payment',
         severity: 'warning',
       });
     }

     // Check marital status and other adults consistency
     if ((answers.maritalStatus === 'Married' || answers.maritalStatus === 'Common-law') &&
         answers.otherAdults === 'No') {
       issues.push({
         fieldId: 'otherAdults',
         message: 'You indicated married/common-law status but said no other adults live with you',
         severity: 'error',
       });
     }

     // Check review declarations
     const declarations = ['infoAccurate', 'reportChanges', 'consentToVerify'];
     const missingDeclarations = declarations.filter(d => !answers[d]);
     if (missingDeclarations.length > 0 && Object.keys(answers).length > 5) {
       missingDeclarations.forEach(fieldId => {
         issues.push({
           fieldId,
           message: 'This declaration must be checked before submitting',
           severity: 'error',
         });
       });
     }

     const response: ValidateResponse = {
       valid: issues.filter(i => i.severity === 'error').length === 0,
       issues,
     };

     res.json(response);
   });
   ```

3. Add validate router to backend/src/index.ts:

   Add import:
   ```typescript
   import { validateRouter } from './routes/validate';
   ```

   Add route:
   ```typescript
   app.use('/validate', validateRouter);
   ```

   Update console.log:
   ```typescript
   console.log('  POST /validate    - Validate form answers');
   ```
  </action>
  <verify>
    - `cat backend/src/routes/validate.ts` shows POST / with consistency checks
    - `cat backend/src/types/index.ts` shows ValidateRequest, ValidationIssue, ValidateResponse
    - `grep -n "validate" backend/src/index.ts` shows validate route registered
    - Start backend with `cd backend && npm run dev` and test:
      ```bash
      curl -X POST http://localhost:5001/validate \
        -H "Content-Type: application/json" \
        -d '{"answers":{"employmentIncome":"Yes"}}'
      ```
      Should return issues array with warning about missing monthlyEarnings
  </verify>
  <done>Validate endpoint created with consistency checks for income, housing, marital status, and declarations</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Backend compiles and runs:
   ```bash
   cd backend && npm run dev
   ```
   Should show "Connected to MongoDB" if MONGODB_URI is set

2. Session endpoints work:
   ```bash
   # Create session
   curl -X POST http://localhost:5001/session \
     -H "Content-Type: application/json" \
     -d '{"answers":{"residencyStatus":"Yes"}}'
   # Returns: {"sessionId":"<uuid>","message":"Session created"}

   # Load session (use sessionId from above)
   curl http://localhost:5001/session/<sessionId>
   # Returns: session data with answers
   ```

3. Validate endpoint works:
   ```bash
   curl -X POST http://localhost:5001/validate \
     -H "Content-Type: application/json" \
     -d '{"answers":{"employmentIncome":"Yes","maritalStatus":"Married","otherAdults":"No"}}'
   # Returns: {"valid":false,"issues":[...]}
   ```

4. Health check still works:
   ```bash
   curl http://localhost:5001/
   # Returns: {"status":"ok",...}
   ```
</verification>

<success_criteria>
- Mongoose installed and Session model created
- MongoDB connection established on server start
- GET /session/:id returns session data or 404
- POST /session creates new session with UUID or updates existing
- POST /validate returns consistency issues for form answers
- All existing endpoints (/explain, /chat, /) still work
</success_criteria>

<output>
After completion, create `.planning/phases/03-polish-persistence/03-01-SUMMARY.md`
</output>
