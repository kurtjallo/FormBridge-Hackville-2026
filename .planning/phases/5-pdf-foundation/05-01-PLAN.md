---
phase: 5-pdf-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/types/pdf.ts
  - backend/src/data/categories.ts
  - backend/src/data/forms-metadata.ts
  - backend/src/routes/categories.ts
  - backend/src/routes/pdf.ts
  - backend/src/services/gcsStorage.ts
  - backend/src/utils/pdfValidation.ts
  - backend/src/index.ts
  - frontend/src/types/pdf.ts
  - frontend/src/store/pdfStore.ts
  - frontend/src/components/pdf/PDFViewer.tsx
  - frontend/src/lib/pdfApi.ts
  - frontend/next.config.ts
  - frontend/package.json
  - backend/package.json
autonomous: true
user_setup:
  - "Set GCS_BUCKET_NAME in backend/.env"
  - "Ensure GOOGLE_APPLICATION_CREDENTIALS points to service account JSON (or use default credentials)"

must_haves:
  truths:
    - "PDF viewer displays with correct page count"
    - "User can navigate pages and zoom level persists"
    - "XFA forms are rejected with user-friendly error message"
    - "Malicious PDFs (invalid format, oversized, JavaScript) are blocked on upload"
    - "Backend serves valid PDFs from GCS via /api/pdf/:formId"
    - "User can upload PDFs to GCS via /api/pdf/upload"
  artifacts:
    - path: "backend/src/types/pdf.ts"
      provides: "Category, PDFFormInfo, PDFField TypeScript interfaces"
      exports: ["Category", "PDFFormInfo", "PDFField", "PDFAnalysisResult"]
    - path: "frontend/src/store/pdfStore.ts"
      provides: "Zustand store for PDF state"
      exports: ["usePdfStore"]
    - path: "frontend/src/components/pdf/PDFViewer.tsx"
      provides: "PDF viewing component with react-pdf"
      exports: ["PDFViewer"]
    - path: "backend/src/routes/pdf.ts"
      provides: "PDF serving and upload with validation and XFA detection"
      exports: ["router"]
    - path: "backend/src/services/gcsStorage.ts"
      provides: "Google Cloud Storage client for PDF upload/download"
      exports: ["uploadPDF", "downloadPDF", "getPDFSignedUrl", "deletePDF"]
    - path: "backend/src/utils/pdfValidation.ts"
      provides: "PDF validation and XFA detection utilities"
      exports: ["validatePDF", "isXFAForm", "PDF_VALIDATION_ERROR", "XFA_ERROR_MESSAGE"]
  key_links:
    - from: "frontend/src/components/pdf/PDFViewer.tsx"
      to: "pdfStore"
      via: "Zustand hook for currentPage, scale state"
      pattern: "usePdfStore"
    - from: "backend/src/routes/pdf.ts"
      to: "backend/src/utils/pdfValidation.ts"
      via: "validatePDF and isXFAForm calls before serving"
      pattern: "(validatePDF|isXFAForm).*buffer"
    - from: "backend/src/routes/pdf.ts"
      to: "backend/src/services/gcsStorage.ts"
      via: "downloadPDF/uploadPDF for GCS operations"
      pattern: "(downloadPDF|uploadPDF|getPDFSignedUrl)"
---

<objective>
Establish PDF infrastructure: TypeScript types, Zustand store for PDF state, react-pdf viewer component, GCS storage service, and backend routes for serving/uploading PDFs with validation and XFA detection.

Purpose: Create the foundation for all PDF-related features in v2.0. All PDFs (pre-loaded forms and user uploads) are stored in Google Cloud Storage.

Output:
- Backend: PDF types, GCS storage service, category/form metadata, PDF serving/upload routes with validation and XFA detection
- Frontend: PDF types, pdfStore, PDFViewer component with zoom and page navigation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/API-CONTRACT-v2.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md

# Existing code to extend
@frontend/src/types/index.ts
@frontend/src/store/formStore.ts
@frontend/src/lib/api.ts
@frontend/next.config.ts
@backend/src/types/form.ts
@backend/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend PDF types, GCS storage, metadata, and routes</name>
  <files>
    backend/src/types/pdf.ts
    backend/src/services/gcsStorage.ts
    backend/src/data/categories.ts
    backend/src/data/forms-metadata.ts
    backend/src/routes/categories.ts
    backend/src/routes/pdf.ts
    backend/src/utils/pdfValidation.ts
    backend/src/index.ts
    backend/package.json
  </files>
  <action>
1. Create `backend/src/types/pdf.ts` with interfaces from API-CONTRACT-v2.md:
   - Category: { id, name, description, icon, formCount }
   - PDFFormInfo: { id, name, description, gcsPath, pageCount, hasEligibilityCheck, signatureRequired }
   - PDFField: { id, name, type, label, page, bbox, required, options? }
   - PDFAnalysisResult: { pdfId, fields, textContent, isXFA, hasAcroForm }
   - PDFUploadResult: { pdfId, filename, gcsPath, pageCount, isXFA, hasAcroForm }

2. Create `backend/src/services/gcsStorage.ts` - Google Cloud Storage service:
   ```typescript
   import { Storage } from '@google-cloud/storage';

   const storage = new Storage();
   const bucketName = process.env.GCS_BUCKET_NAME!;
   const bucket = storage.bucket(bucketName);

   // Upload PDF to GCS
   export async function uploadPDF(buffer: Buffer, filename: string): Promise<string> {
     const gcsPath = `pdfs/${Date.now()}-${filename}`;
     const file = bucket.file(gcsPath);
     await file.save(buffer, { contentType: 'application/pdf' });
     return gcsPath;
   }

   // Download PDF from GCS
   export async function downloadPDF(gcsPath: string): Promise<Buffer> {
     const file = bucket.file(gcsPath);
     const [contents] = await file.download();
     return contents;
   }

   // Get signed URL for direct browser access (optional, for performance)
   export async function getPDFSignedUrl(gcsPath: string, expiresInMinutes = 60): Promise<string> {
     const file = bucket.file(gcsPath);
     const [url] = await file.getSignedUrl({
       action: 'read',
       expires: Date.now() + expiresInMinutes * 60 * 1000,
     });
     return url;
   }

   // Delete PDF from GCS
   export async function deletePDF(gcsPath: string): Promise<void> {
     const file = bucket.file(gcsPath);
     await file.delete();
   }

   // Check if PDF exists
   export async function pdfExists(gcsPath: string): Promise<boolean> {
     const file = bucket.file(gcsPath);
     const [exists] = await file.exists();
     return exists;
   }
   ```

3. Create `backend/src/data/categories.ts` with 5 categories:
   - social-assistance: "Ontario Works, ODSP, and other support programs"
   - education: "OSAP, grants, and student aid"
   - healthcare: "OHIP, drug benefits, and health coverage"
   - housing: "Rent assistance and housing support"
   - legal: "NDAs, consent forms, and legal documents"
   Use icon names: hand-helping, graduation-cap, heart-pulse, home, file-signature

4. Create `backend/src/data/forms-metadata.ts`:
   - Export a forms array with placeholder entries (1-2 per category)
   - Use GCS paths like "pdfs/ontario-works-sample.pdf" (will be uploaded later)
   - Include realistic metadata (pageCount, hasEligibilityCheck, signatureRequired)

5. Create `backend/src/utils/pdfValidation.ts` with two functions:

   **validatePDF(buffer: Buffer): { valid: boolean; error?: string }**
   - Check PDF magic bytes: buffer must start with "%PDF-" (hex: 25 50 44 46 2D)
   - Check file size: reject if > 10MB (10 * 1024 * 1024 bytes)
   - Check for embedded JavaScript: scan buffer string for "/JS" or "/JavaScript"
   - Return { valid: false, error: "descriptive message" } on any failure
   - Return { valid: true } if all checks pass
   - Export PDF_VALIDATION_ERROR constant with user-friendly messages:
     - INVALID_FORMAT: "This file is not a valid PDF document."
     - TOO_LARGE: "PDF file exceeds maximum allowed size of 10MB."
     - CONTAINS_JAVASCRIPT: "This PDF contains JavaScript which is not allowed for security reasons."

   **isXFAForm(buffer: Buffer): boolean**
   - Check for XFA markers in PDF content: "/XFA" or "xmlns:xfa"
   - Return true if XFA detected, false otherwise
   - Export XFA_ERROR_MESSAGE: "This form uses XFA format which is not supported in web browsers. Please use the official PDF reader."

6. Create `backend/src/routes/categories.ts`:
   - GET /api/categories - return all categories with form counts
   - GET /api/categories/:categoryId/forms - return forms for that category

7. Create `backend/src/routes/pdf.ts`:
   - GET /api/pdf/:formId - serve PDF from GCS with validation
   - Implementation steps:
     1. Check if form exists in metadata, return 404 if not
     2. Download PDF buffer from GCS using downloadPDF(gcsPath)
     3. Call validatePDF(buffer) - if not valid, return 400 with error message
     4. Call isXFAForm(buffer) - if XFA detected, return 400 with XFA_ERROR_MESSAGE
     5. Only if both checks pass: set headers and send buffer
        - Content-Type: application/pdf
        - Content-Disposition: inline
   - Handle GCS errors: return 404 with "PDF file not found"

   - POST /api/pdf/upload - upload user PDF to GCS (with multer)
   - Implementation steps:
     1. Accept multipart/form-data with file field
     2. Validate file exists and is PDF (multer fileFilter)
     3. Call validatePDF(buffer) - if not valid, return 400
     4. Call isXFAForm(buffer) - if XFA detected, return 400
     5. Upload to GCS using uploadPDF(buffer, filename)
     6. Return { pdfId, filename, gcsPath, ... }

8. Update `backend/src/index.ts`:
   - Import and mount categories router at /api/categories
   - Import and mount pdf router at /api/pdf

9. Install required packages:
   ```bash
   cd backend && npm install pdf-lib multer @types/multer
   ```
   Note: @google-cloud/storage is already installed.
  </action>
  <verify>
    - `npm run build` in backend succeeds
    - `curl http://localhost:5001/api/categories` returns 5 categories
    - `curl http://localhost:5001/api/categories/social-assistance/forms` returns forms array
    - Types compile without errors
    - GCS_BUCKET_NAME env var is set
    - PDF upload with invalid file returns 400
  </verify>
  <done>
    Backend has Category/PDFFormInfo/PDFField types, GCS storage service, category metadata, categories routes, PDF serving from GCS with validation, and PDF upload endpoint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend PDF types, pdfStore, and react-pdf viewer</name>
  <files>
    frontend/src/types/pdf.ts
    frontend/src/store/pdfStore.ts
    frontend/src/components/pdf/PDFViewer.tsx
    frontend/src/lib/pdfApi.ts
    frontend/next.config.ts
    frontend/package.json
  </files>
  <action>
1. Install react-pdf in frontend:
   ```bash
   cd frontend && npm install react-pdf
   ```

2. Update `frontend/next.config.ts` for react-pdf compatibility:
   ```typescript
   const nextConfig: NextConfig = {
     reactCompiler: true,
     webpack: (config) => {
       config.resolve.alias.canvas = false;
       config.resolve.alias.encoding = false;
       return config;
     },
   };
   ```

3. Create `frontend/src/types/pdf.ts` mirroring backend types:
   - Category, PDFFormInfo, PDFField, PDFAnalysisResult
   - Add PDFState interface for store

4. Create `frontend/src/store/pdfStore.ts` with Zustand:
   ```typescript
   interface PDFState {
     // Current PDF
     currentPdf: { id: string; url: string; name: string } | null;
     setCurrentPdf: (pdf: { id: string; url: string; name: string } | null) => void;

     // Viewer state
     currentPage: number;
     setCurrentPage: (page: number) => void;
     numPages: number;
     setNumPages: (num: number) => void;
     scale: number;
     setScale: (scale: number) => void;

     // Field values (for future use)
     fieldValues: Record<string, string | boolean>;
     setFieldValue: (fieldId: string, value: string | boolean) => void;

     // Active field (for AI integration)
     activeFieldId: string | null;
     setActiveFieldId: (id: string | null) => void;

     // Reset
     reset: () => void;
   }
   ```
   Use persist middleware with key 'formbridge-pdf-storage'

5. Create `frontend/src/lib/pdfApi.ts`:
   - getCategories(): Promise<Category[]>
   - getCategoryForms(categoryId: string): Promise<PDFFormInfo[]>
   - getPDFUrl(formId: string): string - returns full URL to /api/pdf/:formId

6. Create `frontend/src/components/pdf/PDFViewer.tsx`:
   - Use dynamic import with ssr: false for react-pdf Document/Page
   - Props: { pdfUrl: string }
   - Features:
     - Page navigation (prev/next buttons, page indicator "Page X of Y")
     - Zoom controls (zoom in, zoom out, reset to 100%)
     - Scale options: 0.5, 0.75, 1.0, 1.25, 1.5, 2.0
   - Loading state with spinner
   - Error state with user-friendly message
   - Use pdfStore for currentPage, numPages, scale state
   - Set PDF.js worker source: `pdfjs.GlobalWorkerOptions.workerSrc`
   - Use unpkg CDN for worker: `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`
  </action>
  <verify>
    - `npm run build` in frontend succeeds
    - No TypeScript errors in types or store
    - PDFViewer component renders without SSR errors
    - Console shows no react-pdf worker errors
  </verify>
  <done>
    Frontend has PDF types matching backend, pdfStore with viewer state, pdfApi functions, and PDFViewer component with zoom and page navigation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Upload sample PDF to GCS and integration test</name>
  <files>
    backend/scripts/uploadSamplePdf.ts
    frontend/src/app/test-pdf/page.tsx
  </files>
  <action>
1. Create a script to generate and upload a sample PDF to GCS:
   - Create `backend/scripts/uploadSamplePdf.ts`:
     ```typescript
     import { PDFDocument, StandardFonts } from 'pdf-lib';
     import { Storage } from '@google-cloud/storage';
     import dotenv from 'dotenv';

     dotenv.config();

     async function uploadSamplePdf() {
       // Create PDF
       const pdfDoc = await PDFDocument.create();
       const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

       // Page 1
       const page1 = pdfDoc.addPage([612, 792]); // Letter size
       page1.drawText('Sample Government Form', { x: 50, y: 700, size: 24, font });
       page1.drawText('Page 1 - Personal Information', { x: 50, y: 650, size: 14, font });

       // Page 2
       const page2 = pdfDoc.addPage([612, 792]);
       page2.drawText('Page 2 - Employment Details', { x: 50, y: 700, size: 14, font });

       // Page 3
       const page3 = pdfDoc.addPage([612, 792]);
       page3.drawText('Page 3 - Signature', { x: 50, y: 700, size: 14, font });

       const pdfBytes = await pdfDoc.save();

       // Upload to GCS
       const storage = new Storage();
       const bucketName = process.env.GCS_BUCKET_NAME!;
       const bucket = storage.bucket(bucketName);
       const file = bucket.file('pdfs/sample-form.pdf');

       await file.save(Buffer.from(pdfBytes), {
         contentType: 'application/pdf',
         metadata: { cacheControl: 'public, max-age=31536000' }
       });

       console.log(`Uploaded sample-form.pdf to gs://${bucketName}/pdfs/sample-form.pdf`);
     }

     uploadSamplePdf().catch(console.error);
     ```
   - Run with: `cd backend && npx tsx scripts/uploadSamplePdf.ts`

2. Ensure `backend/src/data/forms-metadata.ts` has entry for "sample-form":
   - { id: "sample-form", name: "Sample Government Form", gcsPath: "pdfs/sample-form.pdf", pageCount: 3, ... }
   - categoryId: "social-assistance"

3. Create `frontend/src/app/test-pdf/page.tsx` for testing:
   ```typescript
   'use client';

   import { PDFViewer } from '@/components/pdf/PDFViewer';
   import { getPDFUrl } from '@/lib/pdfApi';

   export default function TestPdfPage() {
     const pdfUrl = getPDFUrl('sample-form');

     return (
       <div className="container mx-auto p-4">
         <h1 className="text-2xl font-bold mb-4">PDF Viewer Test</h1>
         <div className="border rounded-lg overflow-hidden">
           <PDFViewer pdfUrl={pdfUrl} />
         </div>
       </div>
     );
   }
   ```

4. Test the full flow:
   - Ensure GCS_BUCKET_NAME is set in backend/.env
   - Run upload script: `cd backend && npx tsx scripts/uploadSamplePdf.ts`
   - Start backend: `cd backend && npm run dev`
   - Start frontend: `cd frontend && npm run dev`
   - Visit http://localhost:3000/test-pdf
   - Verify PDF displays, zoom works, page navigation works
  </action>
  <verify>
    - Sample PDF exists in GCS bucket at pdfs/sample-form.pdf
    - curl http://localhost:5001/api/pdf/sample-form returns PDF binary
    - http://localhost:3000/test-pdf shows the PDF with controls
    - Page navigation shows "Page 1 of 3" and works
    - Zoom controls change the PDF size
  </verify>
  <done>
    Sample PDF uploaded to GCS, forms metadata references GCS path, test page works, PDF viewer displays with zoom and navigation controls.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Backend builds and runs without errors
2. Frontend builds and runs without errors
3. GET /api/categories returns 5 categories
4. GET /api/categories/social-assistance/forms returns forms array
5. GET /api/pdf/sample-form returns PDF binary from GCS (after passing validation)
6. POST /api/pdf/upload accepts PDF and uploads to GCS
7. /test-pdf page displays PDF with working controls
8. No console errors related to react-pdf or SSR
9. Invalid PDF upload returns 400 with appropriate error message
10. XFA PDF returns 400 with user-friendly XFA error message
</verification>

<success_criteria>
- PDF types defined in both backend and frontend
- GCS storage service handles upload/download operations
- pdfStore manages viewer state (page, zoom)
- PDFViewer component renders PDFs with zoom and page navigation
- Backend serves PDFs from GCS via /api/pdf/:formId with validation
- Backend accepts user uploads via POST /api/pdf/upload to GCS
- Malicious PDF validation blocks invalid format, oversized, and JavaScript-containing PDFs (PDF-05)
- XFA detection rejects unsupported forms with user-friendly message
- Sample PDF uploaded to GCS for testing
</success_criteria>

<output>
After completion, create `.planning/phases/5-pdf-foundation/05-01-SUMMARY.md`
</output>
